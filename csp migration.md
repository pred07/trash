# CSP Migration: Handling AJAX & "Zero-Miss" Detection

This guide focuses on **Content Security Policy (CSP)** implementation and how AJAX fits into the refactoring process.

---

## 1. Do we need to "Refactor" AJAX for CSP?

**Generally, NO.** AJAX is easier to handle than Inline Scripts.

### The Check: "Inline Scripts" vs "AJAX"
*   **Inline Scripts (`onclick="..."`)**: **HARD.** You MUST refactor these by moving code to external `.js` files or adding a `nonce`.
*   **AJAX (`fetch` inside a `.js` file)**: **EASY.** You do **NOT** need to move the code. You only need to **whitelist the URL**.

### The Exception: "Dynamic Script Loading"
If your AJAX fetches code to run it (using `eval` or appending `<script>`), this **WILL** break under CSP.
*   **Refactoring Needed:** High. You must replace `eval()` usage or use `strict-dynamic`.

---

## 2. CSP Directives for AJAX

When you see an AJAX call in the scanner, it maps to a specific CSP Directive:

| AJAX Capability | Relevant CSP Directive | Difficulty |
| :--- | :--- | :--- |
| **Data Exchange** (`fetch`, `xhr`) | `connect-src` | ðŸŸ¢ **Easy** (Add domain to allowlist) |
| **Telemetry** (`sendBeacon`) | `connect-src` | ðŸŸ¢ **Easy** |
| **CSS Loading** (Dynamic Styles) | `style-src` | ðŸŸ¡ **Medium** (May need `unsafe-inline` if creating tags) |
| **Script Loading** (Dynamic JS) | `script-src` | ðŸ”´ **Hard** (Often blocked, requires refactoring) |
| **UI Injection** (HTML Strings) | `script-src` | ðŸŸ¡ **Medium** (Only if HTML contains `<script>`) |

---

## 3. Using RepoScan for "Research"

The scanner is your **Discovery Tool**. It identifies "Why is AJAX used here?" so you can plan the CSP.

### Step-by-Step Research Workflow:

1.  **Run RepoScan**: Get the Excel Report.
2.  **Filter for "AJAX Calls"**: Look at files with `Has_Ajax_Calls = Yes`.
3.  **Identify "Risky" AJAX**:
    *   Search for `.getScript` or `eval` â†’ **Priority 1 for CSP**.
    *   Search for `.html` or `.innerHTML` â†’ **Priority 2 (XSS Check)**.
    *   Rest are likely standard Data calls (`connect-src` only).
4.  **Result**: You now have a list of all external domains you need to verify for your `connect-src` policy.

---

## 4. Strategy for "Zero-Miss" Detection (100% Accuracy)

To guarantee you find **every single** AJAX call without a 1% miss rate, use this **Hybrid Strategy**:

### Layer 1: The "Definitive" Regex (Static Analysis)
**Tool:** RepoScan (repo_depth_analyser)
*   **What it does:** Finds every *attempt* to make a call in the code.
*   **Why it's 99%:** It covers all standard libraries (jQuery, Axios, Fetch, XHR).
*   **How to verify:** Grep for generic terms like `http://`, `https://`, `.com` to find weird hardcoded calls not using standard libraries.

### Layer 2: The "Network Trap" (Dynamic Analysis)
**Tool:** Browser DevTools (Network Tab) / Crawler
*   **What it does:** Catches calls generated by **obfuscated** or **complex** code.
*   **Scenario:**
    ```javascript
    // Regex might miss this if obfuscated
    var f = window['fet' + 'ch']; 
    f('/api/secret');
    ```
*   **Solution:** Run the app, click every button, and record the Network Log. Use a Crawler if possible.

### Layer 3: The "CSP Report-Only" Mode (The Ultimate Net)
**Tool:** Production Env
*   **Strategy:** Deploy a header: `Content-Security-Policy-Report-Only: connect-src 'none'; report-uri /log`.
*   **Result:** The browser will **tell you** every time an AJAX call happens that you didn't allow.
*   **Miss Rate:** **0%**. If the browser tries to fetch it, the browser *will* report it.

---

## Summary

1.  **Refactoring**: Mostly **Configuration** (allowing URLs), not **Code Changes**, unless you are dynamically loading scripts.
2.  **Scanner**: Use it to build your initial `connect-src` allowlist.
3.  **Zero-Miss**: Combine **RepoScan (Static)** with **CSP Report-Only Mode (Dynamic)**. This catches everything, even things you didn't know existed.
